---
title: "flat_compile_qmd_course.Rmd"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = TRUE)
```

## `compile_qmd_course()` : compile individual qmds into a combined html

```{r function-compile_qmd_course}
#' Create a single html from multiple qmd
#'
#' Independently compile several qmd and create a common html
#'
#' @param vec_qmd_path character. Vector of the path to qmd files
#' @param output_dir character. Output path to store html files and companion folders
#' @param output_html character. File name of the complete html output saved
#' @param template character. Path to the template qmd to use. Content will be included at the positions inside double-brackets
#' @param title character. Title of the presentation
#' @param date character. Start and end dates of the training
#' @param trainer character. Name of the trainer
#' @param mail character. Mail of the trainer
#' @param phone character. Phone number of the trainer
#'
#' @importFrom tools file_ext
#' @importFrom htmltools htmlTemplate renderDocument save_html
#' @importFrom furrr future_map_lgl furrr_options
#' @importFrom future plan
#' @importFrom cli cli_alert_info cli_alert_warning
#'
#' @return character. The path to the resulting html file
#'
#' @export
compile_qmd_course <- function(
    vec_qmd_path,
    output_dir,
    output_html,
    template = system.file("template.qmd", package = "squash"),
    title = "Formation R",
    date = "01/01/01-01/01/01",
    trainer = "ThinkR",
    mail = "thinkr.fr",
    phone = "+33 0 00 00 00 00"
) {
  # check paths
  not_all_files_are_qmd <- any(
    file_ext(vec_qmd_path) != "qmd"
  )
  if (isTRUE(not_all_files_are_qmd)) {
    stop("Some of the input files are not qmd files.")
  }
  
  # create output dir and html template
  template_html <- create_template_html(
    path_to_qmd = template,
    output_dir = output_dir,
    output_file = output_html,
    title = title,
    date = date
  )
  
  # list courses files present before rendering
  vec_qmd_dir <- unique(dirname(vec_qmd_path))
  
  file_present_before_rendering <- list.files(
    path = vec_qmd_dir,
    full.names = TRUE,
    include.dirs = TRUE,
    recursive = TRUE
  )
  
  # add compil quarto profile in each directory
  tmp_compil_files <- add_compil_profile_and_extension(
    vec_qmd_path = vec_qmd_path
  )
  
  # set main folder for image
  img_root_dir <- gsub("\\.html", "_img", output_html)
  
  # warn user about {furrr} strategy (e.g. parallel, sequential, default)
  future_setting <- attr(plan(), "call")
  future_setting <- ifelse(
    test = is.null(future_setting),
    yes = 'plan("default")',
    no = deparse(future_setting)
    )
  
  cli_alert_info(paste(
    "{{future}} is using {future_setting},",
    "to modify this use {.code future::plan()}"
  ))
  
  # render each course in parallel
  render_success <- future_map_lgl(
    .x = vec_qmd_path,
    .f = render_single_qmd,
    img_root_dir = img_root_dir,
    # make random number generation reproducible
    .options = furrr_options(seed = TRUE)
    )
  
  # exit and clean if some rendering failed
  if (!all(render_success)){
    clean_rendering_files(
      dir = vec_qmd_dir,
      present_before = file_present_before_rendering,
      extra_files = tmp_compil_files
    )
    return(NULL)
  }

  # read html and extract slides elements
  vec_html_path <- gsub("\\.qmd", "\\.html", vec_qmd_path)
  
  html_content <- extract_html_slides(
    vec_html_path = vec_html_path
  )
  
  # include content in template
  complete_html <- htmlTemplate(
    filename = template_html,
    include_html_content = html_content,
    include_trainer = trainer,
    include_mail = mail,
    include_phone = phone
  ) |>
    renderDocument()
  
  # save html file
  path_to_html <- file.path(
    output_dir,
    output_html
  )
  
  save_html(
    html = complete_html,
    file = path_to_html
  )
  
  # copy all img sub-folders to output_dir
  output_img_dir <- file.path(
    output_dir,
    gsub("\\.html", "_img", output_html)
  )
  
  if (!file.exists(output_img_dir)) {
    dir.create(path = output_img_dir)
  }
  
  vec_img_dir <- file.path(
    vec_qmd_dir,
    gsub("\\.html", "_img", output_html),
    paste0(basename(vec_qmd_dir), "_img")
  )
  
  file.copy(
    from = unique(vec_img_dir),
    to = output_img_dir,
    recursive = TRUE
  )
  
  clean_rendering_files(
    dir = vec_qmd_dir,
    present_before = file_present_before_rendering,
    extra_files = tmp_compil_files
  )
  
  return(
    file.path(
      output_dir,
      output_html
    )
  )
}
```

```{r examples-compile_qmd_course}
library(future)

# set parallel rendering
plan(multisession, workers = 2)

# list example qmds
courses_path <- system.file(
  "courses",
  "M01",
  package = "squash"
)

# copy course tree in tmpdir, add quarto porject file
tmp_course_path <- tempfile(pattern = "course")
dir.create(tmp_course_path)
file.create(file.path(tmp_course_path, "_quarto.yaml"))

file.copy(
  from = courses_path,
  to = tmp_course_path,
  recursive = TRUE
)

qmds <- list.files(
  path = tmp_course_path,
  full.names = TRUE,
  recursive = TRUE,
  pattern = "qmd$"
)

# generate html in temp folder
temp_dir <- tempfile(pattern = "compile")

html_output <- compile_qmd_course(
  vec_qmd_path = qmds,
  output_dir = temp_dir,
  output_html = "complete_course.html"
)

# reset default rendering
plan("default")

# clean up
unlink(temp_dir, recursive = TRUE)
unlink(tmp_course_path, recursive = TRUE)
```

```{r tests-compile_qmd_course}
# list example qmds
courses_path <- system.file(
  "courses",
  package = "squash"
)

# copy course tree in tmpdir
tmp_course_path <- tempfile(pattern = "course")
dir.create(tmp_course_path)
file.create(file.path(tmp_course_path, "_quarto.yaml"))

file.copy(
  from = courses_path,
  to = tmp_course_path,
  recursive = TRUE
)

qmds <- list.files(
  path = tmp_course_path,
  full.names = TRUE,
  recursive = TRUE,
  pattern = "qmd$"
)

# generate html in temp folder
temp_dir <- tempfile(pattern = "compile")

# list files present before rendering (add a dummy one)
file.create(
  file.path(tmp_course_path, "dummy_empty.R")
)

file_present_before_rendering <- list.files(
  path = tmp_course_path,
  full.names = TRUE,
  include.dirs = TRUE,
  recursive = TRUE
)

test_that("compile_qmd_course fails gracefully in case of incorrect inputs", {
  # add path to a html file in list
  qmds_with_missing_path <- c(
    qmds[[1]],
    gsub("\\.qmd", ".html", qmds[[2]])
  )
  
  #' @description test cli_message in case of error in input file type
  compile_qmd_course(
        vec_qmd_path = qmds_with_missing_path,
        output_dir = temp_dir,
        output_html = "complete_course.html"
      ) |> 
    expect_error("Some of the input files are not qmd files.")
})

test_that("compile_qmd_course renders all input courses inside a unique html output", {
  
  # run function
  html_output <- compile_qmd_course(
    vec_qmd_path = qmds,
    output_dir = temp_dir,
    output_html = "complete_course.html"
  )
  
  file_present_after_rendering <- list.files(
    path = tmp_course_path,
    full.names = TRUE,
    include.dirs = TRUE,
    recursive = TRUE
  )
  
  #' @description test that no remaining output files are present
  expect_setequal(
    object = file_present_after_rendering,
    expected = file_present_before_rendering
  )
    
  #' @description test that output html exists
  expect_true(file.exists(html_output))
  
  img_path <- file.path(
    dirname(html_output),
    c(
      "complete_course_img/M01S01_img/img/logo_1.png",
      "complete_course_img/M01S01_img/img/logo_2.png",
      "complete_course_img/M01S02_img/img/logo_1.png",
      "complete_course_img/M02S01-presentation_des_personnes_presentes_img/C03-chevalet_files/figure-revealjs/unnamed-chunk-3-1.png",
      "complete_course_img/M02S01-presentation_des_personnes_presentes_img/C03-chevalet_files/figure-revealjs/unnamed-chunk-4-1.png",
      "complete_course_img/M02S01-presentation_des_personnes_presentes_img/img/bonjour_smiley.png",
      "complete_course_img/M02S01-presentation_des_personnes_presentes_img/img/chevalet_blanc.jpg",
      "complete_course_img/M02S01-presentation_des_personnes_presentes_img/img/crayon.jpg",
      "complete_course_img/M02S01-presentation_des_personnes_presentes_img/img/groupe-conversation.jpg",
      "complete_course_img/M02S01-presentation_des_personnes_presentes_img/img/thinkr-hex.png"
      )
    )

  expected_md5 <- c(
    "ac99473759dd46bf0564047e5cfc2714", 
    "8d77c0f9921459b6fdc64f2cceb7c575", 
    "3b740309e3746c97e95df575801e3253",
    "a0952053e176919b0818139578aea232",
    "701828c6f38c8d2ddbb4301d0d752bad",
    "37943ef4b82d1cfb00c3ffd8b7b13948",
    "1ccfb852f6cd8df7b3d68d51a6f6aec9",
    "29301418b3f7fd256e1f2eb0dc88a136",
    "8ddd7aad8372954c9513115744a719d7",
    "e9f32cf87e5de2e683b3c667226ff127"
    )
  
  #' @description test that output image exist and are the correct ones
  expect_true(all(file.exists(img_path)))
  expect_true(all(tools::md5sum(img_path) == expected_md5))
  
  slide_content <- html_output |>
    read_html() |>
    html_elements(css = ".slides") |>
    html_children() |>
    as.character()
  
  #' @description test html slide content is correct
  expect_snapshot(x = slide_content)

})

test_that("compile_qmd_course HTML preview looks ok", {
  
  # manual check on interactive mode only
  skip_if_not(interactive())
  take_a_look <- yesno::yesno2("\nReady to look at the html preview ?")
  
  if (isTRUE(take_a_look)) {
    cat("Buckle up, html will open in a new pane, come back to this session for validation")
    Sys.sleep(3)
    browseURL(file.path(temp_dir, "complete_course.html"))
    
    questions <- c(
      "\nYou have 23 slides, all with footer and logo ?",
      "\nMain titles are centered, all titles are orange ?",
      "\nImage and code chunk appear properly sized and colored ?",
      "\nGraphics are visible in slides 19 and 20 ?",
      "\nTable is visible in slide 21 ?"
      )
    
    answers <- sapply(
      X = questions,
      FUN = yesno::yesno2
      )
    
    cat("\nThank you :) resuming tests\n")
    
    #' @description testing all visual checks are ok from user answers
    expect_true(all(answers))
  }
})

test_that("compile_qmd_course works with non-default parameters", {

  # run function with other template and parameters
  html_output <- compile_qmd_course(
    vec_qmd_path = qmds[1],
    output_dir = temp_dir,
    output_html = "formation_R.html",
    template = system.file("template_minimal.qmd", package = "squash"),
    title = "Trouloulou",
    date = "66/66/66-66/66/66",
    trainer = "Tralala",
    mail = "Trili@li",
    phone = "+33 6 66 66 66 66"
  )

  #' @description test output has expected name
  expect_true(
    file.exists(
      file.path(temp_dir, "formation_R.html")
    )
  )
  
  first_slide_content <- html_output |>
    read_html() |>
    html_elements(css = ".slides") |>
    html_children() |>
    _[[1]] |> 
    as.character()
  
  #' @description test non-default info are well inserted in minimal template
  expect_snapshot(x = first_slide_content)
  
})

# clean up
unlink(temp_dir, recursive = TRUE)
unlink(tmp_course_path, recursive = TRUE)
```


## `render_single_qmd()` : render a single qmd file to html with image folder

This compilation will use a quarto rendering profile to remove footer, logo and title background. They will be incorporated by the first and last slide template.

This compilation also generates a companion folder storing all the html images.

```{r function-render_single_qmd}
#' Render a qmd course to html 
#' 
#' Render a single qmd file to html with image folder.
#' 
#' @param qmd character. Path to the qmd file to render
#' @param img_root_dir character. Path to the main image folder to extract media to
#' 
#' @importFrom quarto quarto_render
#' @importFrom cli cli_alert_info cli_alert_success cli_alert_danger
#' 
#' @return logical. TRUE if rendering succeeded, FALSE otherwise. Side effect : render qmd as html
#' 
#' @export
render_single_qmd <- function(
    qmd,
    img_root_dir = "img"
) {
  # set image sub-folder name
  chapter <- dirname(qmd)
  
  img_dir <- file.path(
    img_root_dir,
    paste0(basename(chapter), "_img")
  )
  
  # warn user of file rendered
  cli_alert_info("Rendering {qmd}")
  
  # try rendering qmd and warn user if successful / fail
  tryCatch(
    expr = {
      quarto_render(
        input = qmd,
        quiet = TRUE,
        # use revealjs parameter to make a copy of img dir
        # use compil quarto profile to not add logo/bg and footer from quakr
        pandoc_args = c(paste0("--extract-media=", img_dir),
                        "--profile=compil")
      )
      cli_alert_success("{basename(qmd)} rendered successfully")
      return(TRUE)
    },
    error = \(error_message) {
      cli_alert_danger("Fail to render {qmd}, cleaning and existing")
      
      # throw an error with original error message
      return(FALSE)
    }
  )
}
```
  
```{r example-render_single_qmd}
# create a temp dir with qmd
temp_dir <- tempfile(pattern = "render")

dir.create(
  path = file.path(temp_dir, "img"),
  recursive = TRUE
)

file.copy(
  from = system.file("courses", "M01", "M01S01", "C01-qmd1_for_test.qmd", package = "squash"),
  to = temp_dir
)

file.copy(
  from = system.file("courses", "M01", "M01S01", "img", "logo_1.png", package = "squash"),
  to = file.path(temp_dir, "img")
)

# render qmd
is_rendered <- render_single_qmd(
  qmd = file.path(temp_dir, "C01-qmd1_for_test.qmd"),
  img_root_dir = file.path(temp_dir, "image_folder")
)

# clean temp dir
unlink(temp_dir, recursive = TRUE)
```
  
```{r tests-render_single_qmd}
# create a temp dir with qmd
temp_dir <- tempfile(pattern = "render")

dir.create(
  path = file.path(temp_dir, "img"),
  recursive = TRUE
)

file.copy(
  from = system.file("courses", "M01", "M01S01", "C01-qmd1_for_test.qmd", package = "squash"),
  to = temp_dir
)

file.copy(
  from = system.file("courses", "M01", "M01S01", "img", "logo_1.png", package = "squash"),
  to = file.path(temp_dir, "img")
)


test_that("render_single_qmd return an alert for failed rendering", {

  #' @description test cli_message in case of error in rendering
  expect_message(
    object = {
      is_rendered <- render_single_qmd(
        qmd = "a_qmd_that_does_not_exist.qmd"
        )
  },
  regexp = "Fail to render a_qmd_that_does_not_exist.qmd"
  )
  
  #' @description test output is FALSE for incorrect rendering
  expect_true(isFALSE(is_rendered))
  }
)

test_that("render_single_qmd returns message and html", {
  
  #' @description test cli_message in case of success in rendering
  expect_message(
    object = {
      is_rendered <- render_single_qmd(
        qmd = file.path(temp_dir, "C01-qmd1_for_test.qmd"),
        img_root_dir = "img_complete"
        )
  },
  regexp = "C01-qmd1_for_test.qmd rendered successfully"
  )
  
  #' @description test output is FALSE for incorrect rendering
  expect_true(is_rendered)
  
  #' @description test html output exist
  expect_true(
    file.exists(
      file.path(temp_dir, "C01-qmd1_for_test.html")
      )
    )

  #' @description test image path is correct
  img_path <- list.files(
    path = file.path(temp_dir, "img_complete"),
    recursive = TRUE,
    full.names = TRUE
    )
  expect_true(
    object = grepl(
      pattern = "img_complete\\/render.+_img\\/img\\/logo_1.png",
      x = img_path
      )
    )
  
}
)
  
# clean temp dir
unlink(temp_dir, recursive = TRUE)
```
  
```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/flat_compile_qmd_course.Rmd",
  vignette_name = "Compile n qmd to html",
  check = FALSE,
  overwrite = TRUE
)
```