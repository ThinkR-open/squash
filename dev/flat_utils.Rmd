---
title: "flat_additional.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

## `extract_html_slides()` : extract html each elements of slides from multiple html files

```{r function-extract_html_slides}
#' Extract html slide content
#'
#' Extract slide content from multiple html
#'
#' @param vec_html_path character. The vector of path to individual html files
#' @param use_metadata logical. Use the keywords metadata for building the slide's url
#'
#' @importFrom tools file_ext
#' @importFrom rvest read_html html_elements html_children html_attr
#' @importFrom htmltools HTML
#'
#' @return HTML. The HTML slide content of all html files combined together.
#'
#' @export
extract_html_slides <- function(
    vec_html_path,
    use_metadata = TRUE
  ) {
  # verify path are html files
  not_all_files_are_html <- any(
    file_ext(vec_html_path) != "html"
  )
  if (isTRUE(not_all_files_are_html)) {
    stop("Some of the input files are not html files.")
  }
  
  # extract all slides elements
  list_html_slides <- lapply(
    X = vec_html_path,
    FUN = \(html_path) {
      html_path |>
        read_html() |>
        html_elements(".slides") |>
        html_children() |>
        as.character()
    }
  )
  
  # use simple numbering for title slide id
  list_slide_id <- paste0(
    "title-slide-",
    as.character(seq_along(vec_html_path))
  )
  
  if (use_metadata){
  # replace simple numbering by keyword metadata
    list_slide_keywords <- lapply(
      X = vec_html_path,
      FUN = \(html_path) {
        meta <- html_path |>
          read_html() |>
          html_elements("meta")
        meta_name <- html_attr(meta, name = "name")
        meta_content <- html_attr(meta, name = "content")
        keyword <- meta_content[meta_name == "keywords" & !is.na(meta_name)]
        paste0(keyword, collapse = "-")
      }
    )
    
    index_with_keyword <- which(list_slide_keywords != "")
    list_slide_id[index_with_keyword] <- list_slide_keywords[index_with_keyword]
    
    # detect non-unique keywords
    dup_keywords <- anyDuplicated(list_slide_id)
    if (dup_keywords != 0){
      stop(
        "Some keywords are not unique : ",
        toString(list_slide_id[dup_keywords])
      )
    }
  }
  
  # edit content for proper slide formating
  list_html_slides <- lapply(
    X = seq_along(list_html_slides),
    FUN = \(slide_number) {
      list_html_slides[[slide_number]] |>
        # rename 1st slide to avoid duplicated title-slide ids
        gsub(
          pattern = "title-slide",
          replacement = list_slide_id[[slide_number]]
        )
    }
  )
  
  # compile all slides content into a single HTML text
  html_content <- list_html_slides |>
    unlist() |>
    paste0(collapse = "\n") |> 
    HTML()
  
  return(html_content)
}
```

```{r example-extract_html_slides}
# list html files
courses_path <- system.file(
  "courses",
  package = "squash"
)

htmls <- list.files(
  path = courses_path,
  full.names = TRUE,
  recursive = TRUE,
  pattern = "html$"
)

html_slide_content <- extract_html_slides(vec_html_path = htmls)
```

```{r tests-extract_html_slides}
# create temp dir
temp_dir <- tempfile(pattern = "template")
dir.create(temp_dir)

# copy qmd in tmp
squash_path <- system.file(package = "squash")

files_to_copy <- c(
  file.path(
    squash_path,
    c("_extensions",
      file.path("courses", "M01"),
      "_quarto.yaml",
      "_quarto-render.yml")
  )
)

file.copy(
  from = files_to_copy,
  to = temp_dir,
  recursive = TRUE
)

# render all course qmd in quarto project with default profile
# remove as_job to not run as background jobs
quarto::quarto_render(
  input = temp_dir,
  as_job = FALSE
)

# list created html
htmls <- list.files(
  path = temp_dir,
  pattern = "qmd[0-9]_for_test\\.html$",
  recursive = TRUE,
  full.names = TRUE
)
  
test_that("extract_html_slides returns all html slide classes in correct order", {
  
  # run function with slide order 1-2-3
  html_slide_content <- extract_html_slides(
    vec_html_path = htmls,
    use_metadata = TRUE
  )
  
  #' @description test with three html files in order 1-2-3
  section_title <- html_slide_content |>
    read_html() |>
    html_elements(css = "section") |>
    html_attr("id")
  expect_equal(
    object = section_title,
    expected = c(
      "M01S01-1",
      "slide-with-code",
      "slide-dplyr-with-image",
      "title-slide-2",
      "slide-with-speaker-note",
      "slide-with-side-by-side-layout",
      "M01S02-1",
      "slide-with-text",
      "slide-with-text-1",
      "slide-with-ggplot2-image"
    )
  )
  
  # run function with slide order 2-1-3
  html_slide_content_reordered <- extract_html_slides(
    vec_html_path = htmls[c(2, 1, 3)],
    use_metadata = TRUE
  )
  
  #' @description test with three htmls in order 2-1-3
  section_title_reordered <- html_slide_content_reordered |>
    read_html() |>
    html_elements(css = "section") |>
    html_attr("id")
  expect_equal(
    object = section_title_reordered,
    expected = c(
      "title-slide-1",
      "slide-with-speaker-note",
      "slide-with-side-by-side-layout",
      "M01S01-1",
      "slide-with-code",
      "slide-dplyr-with-image",
      "M01S02-1",
      "slide-with-text",
      "slide-with-text-1",
      "slide-with-ggplot2-image"
    )
  )
})

# clean up
unlink(temp_dir, recursive = TRUE)
```

## `create_template_html()` : create a template html with ThinkR styling

Use the quakr extension to render html.

```{r function-create_template_html}
#' Create a themed html from a qmd template
#' 
#' Create a template html with ThinkR styling
#' 
#' @param path_to_qmd character. Path to the qmd template to be rendered in thinkridentity-revealjs
#' @param output_file character. Name of the output html template
#' @param temp_dir character. Path to the temp_dir where template will be rendered
#' 
#' @inheritParams compile_qmd_course
#' 
#' @importFrom quarto quarto_render
#' @importFrom utils download.file unzip
#' @importFrom yaml write_yaml
#'
#' @return character. Path to the html template
#' 
#' @export
create_template_html <- function(
  path_to_qmd,
  output_file,
  output_dir,
  title = "Formation R",
  date = '01/01/01-01/01/01',
  temp_dir = tempfile(pattern = "template")
  ){
    
  # set qmd file name base on html output name
  output_file_qmd <- gsub("\\.html", "\\.qmd", output_file)
  
  # copy qmd template to temp_dir with new name
  if (!file.exists(temp_dir)){
    dir.create(temp_dir, recursive = TRUE)
  }
  
  file.copy(
    from = path_to_qmd,
    to = file.path(
      temp_dir,
      output_file_qmd)
    )
  
  # copy quakr _extensions from {squash} inst
  dir.create(file.path(temp_dir, "_extensions/"))
  
  file.copy(
    from = system.file(
      "_extensions",
      package = "squash"
    ),
    to = temp_dir,
    recursive = TRUE
  )
  
  # define quarto project parameters
  write_yaml(
    x = list(
      "title" = title,
      "subtitle" = date,
      "format" = "thinkridentity-revealjs"
      ),
    file = file.path(temp_dir, "_quarto.yml")
  )
  
  # render template with parameters of quarto project
  quarto_render(
    input = file.path(temp_dir, output_file_qmd),
    quiet = TRUE)
  
  # copy output html and companion folders to output_dir
  files_to_copy <- c(
    "html" = file.path(temp_dir, output_file),
    "lib_folder" = file.path(temp_dir, gsub("\\.html", "_files", output_file)),
    "ext_folder" = file.path(temp_dir, "_extensions")
  )
  
  if (!file.exists(output_dir)){
    dir.create(output_dir, recursive = TRUE)
  }
  
  file.copy(
    from = files_to_copy,
    to = output_dir,
    recursive = TRUE
  )
  
  # remove temp_dir
  unlink(temp_dir, recursive = TRUE)
  
  # return path to html template
  return(file.path(output_dir, output_file))
}
```
  
```{r example-create_template_html}
# create temp dir
temp_dir <- tempfile(pattern = "template")

# create html template
path_to_html_template <- create_template_html(
  path_to_qmd = system.file("template.qmd", package = "squash"),
  output_dir = temp_dir,
  output_file = "complete_course.html"
)

# clean up
unlink(temp_dir, recursive = TRUE)
```
  
```{r tests-create_template_html}
# create temp dir
temp_dir <- tempfile(pattern = "template")

test_that("create_template_html generate an html with proper title and theme", {

  # create html template
  path_to_html_template <- create_template_html(
    path_to_qmd = system.file("template.qmd", package = "squash"),
    output_dir = temp_dir,
    output_file = "complete_course.html"
  )
  
  # list files in extensions
  expect_extension_files <- list.files(
    file.path(temp_dir, "_extensions"),
    recursive = TRUE
  )
  
  # extract html content
  slide_content <- path_to_html_template |>
    read_html() |>
    html_elements(css = ".slides") |>
    html_children()
  slide_id <- slide_content |>
    html_attr(name = "id")
  slide_text <- slide_content |> 
    html_elements("p") |> 
    as.character()
  
  #' @description test quakr extension dir is correctly copied
  expect_setequal(
    object = expect_extension_files,
    expected = c(
      "ThinkR-open/thinkridentity/_extension.yml",
      "ThinkR-open/thinkridentity/background.png",
      "ThinkR-open/thinkridentity/logo.png",
      "ThinkR-open/thinkridentity/logo.svg",
      "ThinkR-open/thinkridentity/thinkridentity.scss"
    )
  )
  
  #' @description test html content of template has correct title and text
  expect_equal(
    object = slide_id,
    expected = c("title-slide", NA, "include_trainer")
  )
  expect_contains(
    object = slide_text,
    expected = c(
      "<p>{{ include_html_content }}</p>",
      "<p><strong>{{ include_phone }}</strong></p>",
      "<p><strong>{{ include_mail }}</strong></p>"
    )
  )
  
})

# clean up
unlink(temp_dir, recursive = TRUE)
```


## `clean_rendering_files()` : cleanup course directory after rendering

Utility function to remove all the files and folders created when rendering a qmd. The files already present and updated will not be removed.
    
```{r function-clean_rendering_files}
#' Clean folder after quarto rendering
#' 
#' Remove all the files and folders created when rendering a qmd to html
#' 
#' @param dir character. The directory to look for rendering output recursively.
#' @param present_before character. Path to the files and directories present before rendering.
#' @param extra_files character. Path of additional files to remove.
#' 
#' @return None. Side effect: remove files that were not present before rendering
#' 
#' @export
clean_rendering_files <- function(
    dir,
    present_before,
    extra_files = NULL
){

  # list files
  present_after <- unique(
    list.files(
      path = dir,
      full.names = TRUE,
      recursive = TRUE,
      include.dirs = TRUE
    )
  )
  
  file_created_by_rendering <- setdiff(
    x = present_after,
    y = path.expand(present_before)
  )
  
  unlink(
    x = file_created_by_rendering,
    recursive = TRUE
  )
  
  unlink(
    x = extra_files,
    recursive = TRUE
  )
  
}
```
  
```{r example-clean_rendering_files}
# create a temp dir with qmd
temp_dir <- tempfile(pattern = "clean")

dir.create(
  path = file.path(temp_dir, "img"),
  recursive = TRUE
)

file.copy(
  from = system.file("courses", "M01", "M01S01", "C01-qmd1_for_test.qmd", package = "squash"),
  to = temp_dir
)

file.copy(
  from = system.file("courses", "M01", "M01S01", "img", "logo_1.png", package = "squash"),
  to = file.path(temp_dir, "img")
)

# list files before rendering
file_and_dirs_before <- list.files(
  temp_dir,
  recursive = TRUE,
  full.names = TRUE,
  include.dirs = TRUE
)

# render qmd
quarto::quarto_render(
  input = file.path(temp_dir, "C01-qmd1_for_test.qmd"),
  quiet = TRUE
)

# remove created files and dirs
clean_rendering_files(
  dir = temp_dir,
  present_before = file_and_dirs_before
)

# clean temp dir
unlink(temp_dir, recursive = TRUE)
```
  
```{r tests-clean_rendering_files}
# create a temp dir with qmd
temp_dir <- tempfile(pattern = "clean")

dir.create(
  path = file.path(temp_dir, "img"),
  recursive = TRUE
)

file.copy(
  from = system.file("courses", "M01", "M01S01", "C01-qmd1_for_test.qmd", package = "squash"),
  to = temp_dir
)

file.copy(
  from = system.file("courses", "M01", "M01S01", "img", "logo_1.png", package = "squash"),
  to = file.path(temp_dir, "img")
)

# list files before rendering
file_and_dirs_before <- list.files(
  temp_dir,
  recursive = TRUE,
  full.names = TRUE,
  include.dirs = TRUE
)

# render qmd
quarto::quarto_render(
  input = file.path(temp_dir, "C01-qmd1_for_test.qmd"),
  quiet = TRUE
)

test_that("clean_rendering_files removes all the file that are generated by quarto rendering", {
  
  # remove created files and dirs
  clean_rendering_files(
    dir = temp_dir,
    present_before = file_and_dirs_before
  )
  
  # list files after rendering
  file_present_now <- list.files(
    temp_dir,
    recursive = TRUE,
    full.names = TRUE,
    include.dirs = TRUE
  )
  
  #' @description test list of files is the same before and after
  expect_setequal(
    object = file_present_now,
    expected = file_and_dirs_before)
  
})

# clean temp dir
unlink(temp_dir, recursive = TRUE)
```

## `add_compil_profile_and_extension()` : detect quarto project and add a temporary compil profile

This function search for existing quarto project for a given set of qmd files and add a yaml profil and quakr extension to use for compilation. If no quarto project exist beforehand, it will stop execution and ask user to create a project.

```{r function-add_compil_profile_and_extension}
#' Detect quarto project and add a temporary compil profile
#' 
#' @param vec_qmd_path character. Path to the qmd files targeted for compilation
#' @param quiet logical. Warn user of project status.
#' 
#' @importFrom quarto quarto_inspect
#' @importFrom cli cli_alert_info
#' @importFrom purrr map map_lgl
#' 
#' @return Create file path. Side effect : create a yaml compil profile.
#' 
#' @noRd
add_compil_profile_and_extension <- function(
  vec_qmd_path,
  quiet = FALSE
  ){
  
  # look for existing quarto projects
  qmd_dir <- dirname(vec_qmd_path)
  
  quarto_proj <- map(
    .x = qmd_dir,
    .f = \(x){
      # return NULL if dir is not a quarto project
      tryCatch(
        expr = {quarto_inspect(x)$dir},
        error = \(e){NULL}
        )
      }
    )
  
  no_quarto_proj <- map_lgl(quarto_proj, is.null)
  qmd_dir_with_no_proj <- unique(qmd_dir[no_quarto_proj])
  qmd_dir_with_proj <- unique(quarto_proj[!no_quarto_proj])
  
  # stop if qmd are not part of a quarto project
  if (length(qmd_dir_with_no_proj) > 0){
    if (!quiet){
    cli_alert_danger(
      paste("No quarto project found for {qmd_dir_with_no_proj}.",
            "Stopping execution.",
            "To setup a quarto project, please visit {.url https://quarto.org/docs/projects/quarto-projects.html}")
      )
    }
    stop("No quarto project found.")
  }

  # add profile and extension in detected projects
  if (length(qmd_dir_with_proj) > 0){
    
    # add a compil profile
    quarto_compil_added <- file.path(
      qmd_dir_with_proj,
      "_quarto-compil.yml"
      )
    
    copied_compil <- map(
      .x = quarto_compil_added,
      .f = \(x){
        copy_if_not_already_exist(
          from = system.file("_quarto-compil.yml", package = "squash"),
          to = x,
          copy_type = "file"
        )
      }
    )

    # add quakr extension
    quarto_quakr_added <- file.path(
      qmd_dir_with_proj,
      "_extensions",
      "ThinkR-open"
    )
    
    copied_quakr <- map(
      .x = quarto_quakr_added,
      .f = \(x){
        copy_if_not_already_exist(
          from = system.file("_extensions",
                             "ThinkR-open",
                             package = "squash"),
          to = x,
          copy_type = "dir"
        )
      }
    )
  }
  
  # return list of created files
  copied_files <- as.character(c(copied_compil, copied_quakr))
  return(copied_files)
}
```
  
```{r example-add_compil_profile_and_extension}
# add a qmd in a tmp dir
tmpdir <- tempfile(pattern = "addcompil")
dir.create(tmpdir)

qmd <- file.path(tmpdir, "dummy.qmd")
file.create(qmd)
file.create(file.path(tmpdir, "_quarto.yaml"))

# init a quarto project
add_compil_profile_and_extension(vec_qmd_path = qmd, quiet = FALSE)

# detects pre-existing
add_compil_profile_and_extension(vec_qmd_path = qmd, quiet = FALSE)

# cleanup
unlink(tmpdir, recursive = TRUE)
```
  
```{r tests-add_compil_profile_and_extension}
test_that("add_compil_profile_and_extension works", {
  # add two qmd in a tmp dir, one with yaml project
  tmpdir <- tempfile(pattern = "addcompil")
  dir.create(file.path(tmpdir, "tmpsubfolder1"), recursive = TRUE)
  dir.create(file.path(tmpdir, "tmpsubfolder2"), recursive = TRUE)
  
  vec_qmd_path <- c(
    file.path(tmpdir, "tmpsubfolder1", "dummy1.qmd"),
    file.path(tmpdir, "tmpsubfolder2", "dummy2.qmd")
  )
  
  file.create(vec_qmd_path)

  #' @description test function stops if not project is found
  expect_error(
    {new_proj_files <- add_compil_profile_and_extension(vec_qmd_path = vec_qmd_path, quiet = FALSE)},
    regexp = "No quarto project found."
  ) |> 
    expect_message(regexp = "No quarto project found")
  
  # add quarto project
  file.create(
    file.path(tmpdir, "_quarto.yaml")
  )
  
  #' @description test function add compil and quakr
  new_proj_files <- add_compil_profile_and_extension(vec_qmd_path = vec_qmd_path, quiet = FALSE)
  
  #' @description test project files are created if not pre existing
  expect_true(all(file.exists(new_proj_files)))
  
  #' @description test user message are sent for compil and quakr theme
  expect_message(
    {new_proj_files <- add_compil_profile_and_extension(vec_qmd_path = vec_qmd_path, quiet = FALSE)},
    regexp = "Using it for compil."
  ) |> 
    expect_message(regexp = "Using it for compil.")
  
  #' @description test project files are not created if pre-existing
  expect_equal(object = new_proj_files, expected = c("NULL", "NULL"))
  
  # cleanup
  unlink(tmpdir, recursive = TRUE)
})
```
  
## `copy_if_not_already_exist()`

Verify a directory or a file is not already existing, and copy it if it is not the case. Warn user otherwise.
    
```{r function-copy_if_not_already_exist}
#' Copy file or directory if they do not already exist
#' 
#' @param from character. The file or directory to copy
#' @param to character. The target path to copy to
#' @param copy_type character. The type of element to copy (file or dir)
#' @param quiet logical. Should the use be warned about pre-existing file/dir
#' 
#' @return character. Path of added file or directory.
#' 
#' @noRd
copy_if_not_already_exist <- function(
    from,
    to,
    copy_type = c("file", "dir"),
    quiet = FALSE
){
  # verify input
  copy_type <- match.arg(copy_type)
  
  # verify files/dir is already present
  already_present <- file.exists(to)
  
  if (already_present) {
    if (!quiet){
      cli_alert_info(
        paste(
          "{to} already present in quarto project.",
          "Using it for compil."
        )
      )
    }
    return(NULL)
  }
  
  if (!already_present){
    if (copy_type == "dir"){
      if (!dir.exists(dirname(to))){
        dir.create(
          dirname(to),
          recursive = TRUE
        )
        to_copied_path <- dirname(to)
      }
      
      file.copy(
        from = from,
        to = dirname(to),
        recursive = TRUE
      )
    } else {
      file.copy(
        from = from,
        to = to
      )
      to_copied_path <- to
    }
  }
  # return path that has been created
  return(to_copied_path)
}
```
  
```{r example-copy_if_not_already_exist}
tmpdir <- tempfile(pattern = "copy")

copy_if_not_already_exist(
  from = system.file("_extensions","ThinkR-open","thinkridentity", package = "squash"),
  to = file.path(tmpdir, "thinkridentity"),
  copy_type = "dir"
)

unlink(tmpdir, recursive = TRUE)
```
  
```{r tests-copy_if_not_already_exist}
test_that("copy_if_not_already_exist works", {
  tmpdir <- tempfile(pattern = "copy")
  
  output <- copy_if_not_already_exist(
    from = system.file("_extensions","ThinkR-open","thinkridentity", package = "squash"),
    to = file.path(tmpdir, "thinkridentity"),
    copy_type = "dir"
  )
  
  #' @description test that first copy create the dir
  expect_true(dir.exists(output))
  
  #' @description test that second copy does nothing
  expect_message(
    {
      output <- copy_if_not_already_exist(
        from = system.file("_extensions","ThinkR-open","thinkridentity", package = "squash"),
        to = file.path(tmpdir, "thinkridentity"),
        copy_type = "dir"
      )
    },
    regexp = "already present in quarto project"
  )
  expect_null(output)
  
  unlink(tmpdir, recursive = TRUE)
})
```
  

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(
  flat_file = "dev/flat_utils.Rmd",
  vignette_name = NA,
  check = FALSE
  )
```

